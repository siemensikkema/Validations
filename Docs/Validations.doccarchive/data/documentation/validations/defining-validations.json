{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Consider the following input."}]},{"type":"codeListing","syntax":null,"code":["{","    \"email\": \"user@example.com\",","    \"oldPassword\": \"insecure\",","    \"newPassword\": \"insecure2\"","    \"confirmation\": \"insecure2\"","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are several things we’d like to validate:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"all fields are present and of the correct type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the new password is strong enough"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the new password equals the value of the confirmation field"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the old password matches that of the user with the given email address"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Normally we’d represent this payload as follows:"}]},{"type":"codeListing","syntax":"swift","code":["struct ResetPasswordRequest: Decodable {","    let email: String","    let oldPassword: String","    let newPassword: String","    let confirmation: String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But in order to use Validations we need to wrap the fields with "},{"type":"codeVoice","code":"Decoded"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct ResetPasswordRequest: Decodable {","    let email: Decoded<String>","    let oldPassword: Decoded<String>","    let newPassword: Decoded<String>","    let confirmation: Decoded<String>","}"]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/validations\/defining-validations"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Validations\/documentation\/Validations\/Defining-Validations","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"We will use a reset password feature as an example to demonstrate how to use this package."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Defining Validations","role":"article","modules":[{"name":"Validations"}]},"hierarchy":{"paths":[["doc:\/\/Validations\/documentation\/Validations"]]},"references":{"doc://Validations/documentation/Validations":{"role":"collection","title":"Validations","abstract":[{"type":"text","text":"Type-safe and composable validations with flexible error output."}],"identifier":"doc:\/\/Validations\/documentation\/Validations","kind":"symbol","type":"topic","url":"\/documentation\/validations"}}}