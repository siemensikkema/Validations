{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will use a fictional reset password feature as an example since it enables us to explore various interesting aspects of validation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Consider the following input:"}]},{"type":"codeListing","syntax":"swift","code":["let payload: Data = \"\"\"","{","    \"email\": \"user@example.com\",","    \"password\": \"insecure\",","    \"newPassword\": \"insecure2\"","    \"confirmation\": \"insecure2\"","}","\"\"\".data(using: .utf8)!"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are several preconditions that the payload needs to meet before we can accept the input and change the user’s password, including:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"all fields are present and of the correct type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"newPassword"},{"type":"text","text":" contains a strong enough password"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"confirmation"},{"type":"text","text":" equals the value of the "},{"type":"codeVoice","code":"newPassword"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"password"},{"type":"text","text":" matches the current password of the user with the given email address"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"More generally these correspond to validating …"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the structure"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"a single field"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"a relationship between fields"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"against an external state"}]}]}]},{"type":"aside","style":"warning","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This example is chosen to highlight "},{"type":"codeVoice","code":"Validations"},{"type":"text","text":"’ features and not intended to be a best practice for building a password reset implementation."}]}]},{"anchor":"Representing-the-payload","level":2,"type":"heading","text":"Representing the payload"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Traditionally we’d represent a payload like the above as follows:"}]},{"type":"codeListing","syntax":"swift","code":["struct ResetPasswordRequest: Decodable { \/\/ ❌","    let email: String","    let password: String","    let newPassword: String","    let confirmation: String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Defining the payload like this would cause decoding to fail on the first mismatch between the input and the type."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"One could define the fields as "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" which would prevent decoding to fail on missing or "},{"type":"codeVoice","code":"null"},{"type":"text","text":" values but that would not convey the intended structure. Moreover, it would still fail if a field would be present but of the wrong type, say an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" instead of a "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By wrapping the fields with "},{"type":"codeVoice","code":"Decoded"},{"type":"text","text":" we can capture any and all mismatches while still expressing the proper structure."}]},{"type":"codeListing","syntax":"swift","code":["struct ResetPasswordRequest: Decodable {","    let email: Decoded<String>","    let password: Decoded<String>","    let newPassword: Decoded<String>","    let confirmation: Decoded<String>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we’re ready to decode the input."}]},{"type":"codeListing","syntax":"swift","code":["let decoder = JSONDecoder()","let request = try decoder.decode(Decoded<ResetPasswordRequest>.self, ","                                 from: payload)"]},{"type":"aside","style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note again the presence of the "},{"type":"codeVoice","code":"Decoded"},{"type":"text","text":" wrapper – this time involving our custom type. This allows us to capture top-level decoding errors (eg. trying to decode a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" instead of the expected object) but more importantly it provides access to the validation APIs."}]}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Despite wrapping our fields in "},{"type":"codeVoice","code":"Decoded"},{"type":"text","text":" the decoding operation can still throw. Errors that can still occur include those due to malformed input (eg. "},{"type":"codeVoice","code":"JSON"},{"type":"text","text":" with syntax errors) and the possible presence of any non-"},{"type":"codeVoice","code":"Decoded"},{"type":"text","text":" fields."}]}]},{"anchor":"Validating-the-payload","level":2,"type":"heading","text":"Validating the payload"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s go through the preconditions listed above and see how to express them in "},{"type":"codeVoice","code":"Validations"},{"type":"text","text":"."}]},{"anchor":"1.-Validating-the-structure","level":3,"type":"heading","text":"1. Validating the structure"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we just want to validate that the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"structure"}]},{"type":"text","text":" of our input is correct, validation involves a single operation:"}]},{"type":"codeListing","syntax":"swift","code":["let validated = try request.validated() \/\/ Validated<ResetPasswordRequest>"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Validations\/documentation\/Validations\/Validated"},{"type":"text","text":" on how to use the values in the (now validated) payload and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Validations\/documentation\/Validations\/KeyedFailures"},{"type":"text","text":" on how to handle any resulting validation failures."}]}]},{"anchor":"2.-Validating-a-single-field","level":3,"type":"heading","text":"2. Validating a single field"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Additional validations can be expressed using a special syntax powered by result builders."}]},{"type":"codeListing","syntax":"swift","code":["let validated = try request.validated {","    \\.newPassword.count >= 8","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new validation will fail if "},{"type":"codeVoice","code":"newPassword"},{"type":"text","text":" is present and of the correct type but its "},{"type":"codeVoice","code":"count"},{"type":"text","text":" is less than eight characters."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Validations\/documentation\/Validations\/Validator"},{"type":"text","text":" for available validations."}]}]},{"anchor":"3.-Validating-a-relationship-between-fields","level":3,"type":"heading","text":"3. Validating a relationship between fields"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Besides validations involving fields and values it is also possible to validate a relationship "},{"type":"emphasis","inlineContent":[{"type":"text","text":"between"}]},{"type":"text","text":" fields."}]},{"type":"codeListing","syntax":"swift","code":["\\.confirmation == \\.newPassword"]},{"anchor":"4.-Validating-against-external-state","level":3,"type":"heading","text":"4. Validating against external state"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose we have a credential verification function that can verify that a password is valid for a user with an email address."}]},{"type":"codeListing","syntax":"swift","code":["func verifyCredentials(email: String?,","                       password: String?) async -> ValidationFailure? {","    \/\/ verify credentials","    ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If both email and password have non-nil values, the function performs a database lookup for the user and verifies the password against the stored hashed password. If the password does not match or if no user with the email address could not be found, some "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Validations\/documentation\/Validations\/ValidationFailure"},{"type":"text","text":" is returned."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As the function is marked as "},{"type":"codeVoice","code":"async"},{"type":"text","text":" it cannot be used directly inside the validation builder. We can deal with this by verifying the password first and using the result when building the validator."}]},{"type":"codeListing","syntax":"swift","code":["let credentialFailure = await verifyCredentials(email: payload.email.value, ","                                                password: payload.password.value)","","let validated = try payload.validated {","    \\.newPassword.count > 8","    \\.confirmation == \\.newPassword","","    if let failure = credentialFailure {","        Validator(nestedAt: \\.email, failure: failure)","    }","}"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’re associating the failure with the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"email"}]},{"type":"text","text":" field. The failure could indicate either an incorrect email address or an incorrect password and we don’t want to give any hints to potential bad actors."}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An alternative way to approach this would be to split the validation into two validators and combining them at the validation step."}]},{"type":"codeListing","syntax":"swift","code":["let payloadValidator = Validator<ResetPasswordPayload> {","    \\.newPassword.count > 8","    \\.confirmation == \\.newPassword","}","","let credentialFailure = await verifyCredentials(email: payload.email.value, ","                                                password: payload.password.value)","","let credentialValidator = Validator<ResetPasswordPayload> {","    if let failure = credentialFailure {","        Validator(nestedAt: \\.email, failure: failure)","    }","}","","let validated = try payload.validated(by: payloadValidator, credentialValidator)"]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/validations\/defining-validations"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Validations\/documentation\/Validations\/Defining-Validations","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Define the validation rules that your data should adhere to."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Defining Validations","role":"article","modules":[{"name":"Validations"}]},"hierarchy":{"paths":[["doc:\/\/Validations\/documentation\/Validations"]]},"references":{"doc://Validations/documentation/Validations":{"role":"collection","title":"Validations","abstract":[{"type":"text","text":"Type-safe and composable validations with versatile output."}],"identifier":"doc:\/\/Validations\/documentation\/Validations","kind":"symbol","type":"topic","url":"\/documentation\/validations"},"doc://Validations/documentation/Validations/ValidationFailure":{"role":"symbol","title":"ValidationFailure","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ValidationFailure"}],"abstract":[{"type":"text","text":"Enables conforming types to represent a single validation failure."}],"identifier":"doc:\/\/Validations\/documentation\/Validations\/ValidationFailure","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ValidationFailure"}],"url":"\/documentation\/validations\/validationfailure"},"doc://Validations/documentation/Validations/KeyedFailures":{"role":"symbol","title":"KeyedFailures","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"KeyedFailures"}],"abstract":[{"type":"text","text":"Represents an unsuccessful validation with one or more "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Validations\/documentation\/Validations\/ValidationFailure"},{"type":"text","text":" values per "},{"type":"codeVoice","code":"CodingPath"},{"type":"text","text":"."}],"identifier":"doc:\/\/Validations\/documentation\/Validations\/KeyedFailures","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"KeyedFailures"}],"url":"\/documentation\/validations\/keyedfailures"},"doc://Validations/documentation/Validations/Validator":{"role":"symbol","title":"Validator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Validator"}],"abstract":[{"type":"text","text":"Able to validate a "},{"type":"codeVoice","code":"Decoded<T>"},{"type":"text","text":" value."}],"identifier":"doc:\/\/Validations\/documentation\/Validations\/Validator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Validator"}],"url":"\/documentation\/validations\/validator"},"doc://Validations/documentation/Validations/Validated":{"role":"symbol","title":"Validated","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Validated"}],"abstract":[{"type":"text","text":"A proxy for a successfully decoded and validated value."}],"identifier":"doc:\/\/Validations\/documentation\/Validations\/Validated","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Validated"}],"url":"\/documentation\/validations\/validated"}}}